static pointer CLO554();
static pointer CLO555();
static pointer CLO559();
static pointer CLO560();
static pointer CLO562();
static pointer CLO563();
static pointer CLO586();
static pointer CLO648();
static pointer UWP822();
static pointer (*ftab[23])();

#define QUOTE_STRINGS_SIZE 297
static char *quote_strings[QUOTE_STRINGS_SIZE]={
    "send",
    "*debug*",
    "\";; (forward-message-to ~A ~A) ~%\"",
    "warn",
    "send-all",
    "\";; (forward-message-to-all ~A ~A) ~%\"",
    "apply",
    "function",
    "send-message",
    "prog1",
    "while",
    "and",
    "null",
    "select-stream",
    "list",
    "*standard-input*",
    "1.000000e-07",
    "eval",
    "let",
    "strm",
    "car",
    "0.1",
    "if",
    "read-line",
    "nil",
    "do-until-key-with-check",
    "t",
    "instance",
    "mtimer",
    ":init",
    "<",
    ":stop",
    ":start",
    "cons",
    "-",
    "(nil)",
    ":count",
    "remove",
    "(nil)",
    "member",
    "#(:key :identity :bigger)",
    "identity",
    "=",
    ">",
    "#(:host)",
    ":host",
    ":domain",
    ":port",
    "make-socket-address",
    "make-socket-port",
    "socket-port",
    "*top-selector*",
    ":add-port",
    "(lambda (s) (let ((strm (make-server-socket-stream s))) (send *top-selector* :add-port strm '(lambda (s) (let ((c (read-char s nil nil))) (cond ((null c) (send *top-selector* :remove-port s) (close s)) (t (unread-char c s) (funcall 'lisp::repsel s (gensym) nil nil))))) strm)))",
    "\"eus-server; port:~A host:~A\"",
    "#(:max-port :return-with-port)",
    "connect-server",
    "\";;; Connected server: ~c[31m~a@~a~c[m~%\"",
    "\";;; Can't connect server (~c[31m~a@~a-~a~c[m).~%\"",
    "\"\"",
    "*error-output*",
    ":element-type",
    ":integer",
    "\"~~~dd \"",
    ":float",
    "\"~~~d,~df \"",
    "\"~~~AA\"",
    "vector",
    "\"~%\"",
    "array",
    "array-dimensions",
    "/=",
    "\" \"",
    "\"~%\"",
    "concatenate",
    "string",
    "gensym",
    "#(:position-list :time-list)",
    ":position-list",
    ":time-list",
    "\"length of position-list must be length of time-list + 1\"",
    "warning-message",
    ":interpolation",
    "last",
    ":reset",
    "#(:velocity-list :acceleration-list)",
    ":velocity-list",
    ":acceleration-list",
    "super",
    ":initial-element",
    "float-vector",
    "make-list",
    "v+",
    "reduce",
    "expt",
    "(0 6)",
    "1",
    "2",
    "3",
    "4",
    "5",
    "\"hri2rgb error\"",
    ":print-string",
    "\"time\"",
    "progn",
    "format",
    "\";; ~A -> ~A[s]~%\"",
    "with-all-output->file",
    "\"/dev/null\"",
    "*standard-output*",
    "unwind-protect",
    "with-open-file",
    ":direction",
    ":output",
    "setq",
    "quote",
    "eq",
    "finish-output",
    "read-char",
    "case",
    ":char",
    ":byte",
    ":start1",
    ":end2",
    "replace",
    "unix:tcgetattr",
    "\"0\"",
    "copy-list",
    "unix:tcsetattr",
    "piped-fork",
    "string-downcase",
    "robot-model",
    ":hierarchy",
    "flatten",
    ":name",
    "string=",
    "\"~A-robot\"",
    "\"USER\"",
    "\"USER\"",
    "*package*",
    "\"no such package\"",
    "(forward-message-to forward-message-to-all)",
    "forward-message-to",
    "\"forward _args_ message to _to_ object\"",
    "forward-message-to-all",
    "\"forward _args_ message to all _to_ object\"",
    "send-message*",
    "\"(&rest msgs)\"",
    "\"(check &rest forms)\"",
    "do-until-key",
    "\"iterate forms until any key input\"",
    "do-until-key-with-timer",
    "\"(time-limit &rest forms)\"",
    ":global",
    ":super",
    "object",
    ":slots",
    "(buf)",
    ":metaclass",
    ":size",
    ":documentation",
    "make-class",
    "\"Initialize timer object.\"",
    "\"Start timer.\"",
    "\"Stop timer and returns elapsed time in seconds.\"",
    "permutation",
    "\"Returns permutation of given list\"",
    "combination",
    "\"Returns combination of given list\"",
    "mapjoin",
    "\"(expr seq1 seq2)\"",
    "find-extreams",
    "\"Returns the elements of datum which maximizes key function\"",
    "need-thread",
    "\"(n &optional (lsize (* 512 1024)) (csize lsize))\"",
    "eus-server",
    "\"Create euslisp interpreter server, data sent to socket is evaluated as lisp expression\"",
    "connect-server-until-success",
    "\"Connect euslisp interpreter server until success\"",
    "format-array",
    "\"print formatted array\"",
    "with-gensyms",
    "\"(syms &rest bodies)\"",
    "interpolator",
    "propertied-object",
    "((position-list :type cons) (time-list :type cons) (position :type float-vector) (time :type float) (segment-num :type integer) (segment-time :type float) (segment :type integer) (interpolatingp :type symbol))",
    "\"Abstract class of interpolator\"",
    "\"Initialize interpolator\n   position-list: list of control point\n   time-list: list of time from start for each control point, time in fisrt contrall point is zero, so length of this list is length of control point minus 1\"",
    "\"returns position list\"",
    ":position",
    "\"returns current position\"",
    "\"returns time list\"",
    ":time",
    "\"returns current time\"",
    ":segment-time",
    "\"returns time[sec] with in each segment\"",
    ":segment",
    "\"returns index of segment which is currently processing\"",
    ":segment-num",
    "\"returns number of total segment\"",
    ":interpolatingp",
    "\"returns if it is currently processing\"",
    ":start-interpolation",
    "\"start interpolation\"",
    ":stop-interpolation",
    "\"stop interpolation\"",
    ":pass-time",
    "\"process interpolation for dt[sec]\"",
    "linear-interpolator",
    "\"Linear interpolator\"",
    "minjerk-interpolator",
    "(velocity acceleration velocity-list acceleration-list)",
    ":velocity",
    "\"returns current velocity\"",
    "\"returns velocity list\"",
    ":acceleration",
    "\"returns current acceleration\"",
    "\"returns acceleration list\"",
    "\"minjerk interopolator\n    position-list : list of control point\n    velocity-list : list of velocity in each control point\n    acceleration-list : list of acceleration in each control point\"",
    "\"Minjerk interpolator, a.k.a Hoff & Arbib\n\n    Example code is:\n(setq l (instance minjerk-interpolator :init))\n(send l :reset :position-list (list #f(1 2 3) #f(3 4 5) #f(1 2 3)) :time-list (list 0.1 0.18))\n(send l :start-interpolation)\n(while (send l :interpolatingp) (send l :pass-time 0.02) (print (send l :position)))\n\"",
    "his2rgb",
    "\"convert his to rgb (0 <= h <= 360, 0.0 <= i <= 1.0, 0.0 <= s <= 1.0)\"",
    "hvs2rgb",
    "\"convert hvs to rgb (0 <= h <= 360, 0.0 <= i <= 1.0, 0.0 <= s <= 1.0)\"",
    "rgb2his",
    "\"convert rgb to his (0 <= r,g,b <= 255)\"",
    "rgb2hvs",
    "\"convert rt to hvs (0 <= r,g,b <= 255)\"",
    "color-category10",
    "\"Choose good color from 10 colors\"",
    "color-category20",
    "\"Choose good color from 20 colors\"",
    "bench",
    "\"calculating execution time using mtimer, bench returns the value of args where the arbitrary lisp form\n(bench (unix:sleep 1))\n;; time -> 1.0001[s]\nt\n\"",
    "bench2",
    "\"calculating execution time using mtimer, bench2 returns the execution time of args where the arbitrary lisp form\n(bench2 (unix:sleep 1))\n1.00024\n\"",
    "null-output",
    "\"(&rest bodies)\"",
    "\"(fname &rest bodies)\"",
    "read-char-case",
    "\"read one charactor with lower caes\n(read-char-case \\\"y or n or r: \\\"\n (#y (format t \\\"yes~%\\\") t)\n (#n (format t \\\"no~%\\\") t)\n (#r (format t \\\"retry~%\\\") t))\n\"",
    "termios",
    "cstruct",
    "cstructclass",
    ":slotlist",
    "((c_iflag :integer) (c_oflag :integer) (c_cflag :integer) (c_lflag :integer) (c_line :char) (c_cc :char 19) (c_ispeed :integer) (c_ospeed :integer))",
    "termios-c_iflag",
    "\"(lisp::s)\"",
    "set-termios-c_iflag",
    "lisp::setf-update-fn",
    "lisp::setf-lambda",
    "remprop",
    "lisp::setf-method",
    "lisp::setf-documentation",
    "\"(lisp::s lisp::val)\"",
    "termios-c_oflag",
    "\"(lisp::s)\"",
    "set-termios-c_oflag",
    "\"(lisp::s lisp::val)\"",
    "termios-c_cflag",
    "\"(lisp::s)\"",
    "set-termios-c_cflag",
    "\"(lisp::s lisp::val)\"",
    "termios-c_lflag",
    "\"(lisp::s)\"",
    "set-termios-c_lflag",
    "\"(lisp::s lisp::val)\"",
    "termios-c_line",
    "\"(lisp::s)\"",
    "set-termios-c_line",
    "\"(lisp::s lisp::val)\"",
    "termios-c_cc",
    "\"(lisp::s &optional lisp::i)\"",
    "set-termios-c_cc",
    "\"(lisp::s lisp::i &rest lisp::val)\"",
    "termios-c_ispeed",
    "\"(lisp::s)\"",
    "set-termios-c_ispeed",
    "\"(lisp::s lisp::val)\"",
    "termios-c_ospeed",
    "\"(lisp::s)\"",
    "set-termios-c_ospeed",
    "\"(lisp::s lisp::val)\"",
    "tcsanow",
    ":constant",
    "tcsadrain",
    "tcsaflush",
    "icanon",
    "kbhit",
    "\"Checks the console for a keystroke. retuns keycode value if a key has been pressed, otherwise it returns nil. Note that this does not work well on Emacs Shell mode, run EusLisp program from terminal shell.\"",
    "piped-fork-returns-list",
    "\"piped fork returning result as list\"",
    "make-robot-model-from-name",
    "\"make a robot model from string: (make-robot-model \\\"pr2\\\")\"",
    ":irtutil",
    "\"$Id$\"",
    "provide",
  };
